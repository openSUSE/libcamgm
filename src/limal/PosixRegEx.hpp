/*******************************************************************************
* Copyright (C) 2005 Novell, Inc. All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*
*  - Redistributions of source code must retain the above copyright notice,
*    this list of conditions and the following disclaimer.
*
*  - Redistributions in binary form must reproduce the above copyright notice,
*    this list of conditions and the following disclaimer in the documentation
*    and/or other materials provided with the distribution.
*
*  - Neither the name of Quest Software, Inc., Novell, Inc., nor the names of its
*    contributors may be used to endorse or promote products derived from this
*    software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS IS''
* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
* ARE DISCLAIMED. IN NO EVENT SHALL Quest Software, Inc., Novell, Inc., OR THE
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
* OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
* WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
* OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
* ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*******************************************************************************/
/**
 * @author Marius Tomaschewski
 */

#ifndef   LIMAL_POSIX_REGEX_HPP
#define   LIMAL_POSIX_REGEX_HPP

#include <limal/String.hpp>
#include <vector>

#include <regex.h>

namespace ca_mgm
{

/**
 * POSIX Regular Expression wrapper class and utility functions.
 *
 * Depends on avaliability of a POSIX.2 / SUSv2 conforming
 * regcomp(3) and regexec(3) function implementation.
 *
 * Consult the regcomp(3), regexec(3) and regex(7) manual pages
 * for informations about details of the posix regex usage.
 */
class PosixRegEx
{
public:
	/**
	 * POSIX RegEx structure for captured substring offset pair.
	 * The regex match structure contains two member variables:
	 * @arg @c rm_so  start offset of the regex match
	 * @arg @c rm_eo  end offset of the regex match
	 */
	typedef regmatch_t                      match_t;

	/**
	 * Array of captured substring offsets.
	 */
	typedef std::vector<match_t>          MatchArray;

	/**
	 * Create a new PosixRegEx object without compilation.
	 */
	PosixRegEx();

	/**
	 * Create a new PosixRegEx object and compile the regular expression.
	 *
	 * See also compile() method.
	 *
	 * @param  regex   A regular expression pattern.
	 * @param  cflags  Bitwise-or of compilation flags.
	 * @throws RegExCompileException on compilation failure.
	 */
	PosixRegEx(const std::string &regex, int cflags = REG_EXTENDED);

	/**
	 * Create a new PosixRegEx as (deep) copy of the specified reference.
	 * If the reference is compiled, the new object will be compiled
	 * as well.
	 *
	 * @param ref The PosixRegEx object reference to copy.
	 * @throws RegExCompileException on compilation failure.
	 */
	PosixRegEx(const PosixRegEx &ref);

	/**
	 * Destroy this PosixRegEx object.
	 */
	~PosixRegEx();

	/**
	 * Assign the specified PosixRegEx reference. If the reference
	 * is compiled, the current object will be (re)compiled.
	 *
	 * @param ref The PosixRegEx object reference to assign from.
	 * @throws RegExCompileException on compilation failure.
	 */
	PosixRegEx&          operator = (const PosixRegEx &ref);


	/**
	 * Compile the regular expression contained in the string.
	 *
	 * @param  regex   A regular expression pattern.
	 * @param  cflags  Bitwise-or of compilation flags.
	 * @return         True on successful compilation,
	 *                 false on failure.
	 *
	 * The @c cflags parameter can be set to one or a bitwise-or
	 * of the following flags. Consult the regcomp manual page
	 * for the complete (library specific) flag list and detailed
	 * description.
	 *
	 * @arg @c REG_EXTENDED Use Extended Regular Expressions
	 *                      syntax instead of Basic.
	 * @arg @c REG_ICASE    Ignore character case in match.
	 * @arg @c REG_NOSUB    Report match only, do not capture
	 *                      substrings.
	 * @arg @c REG_NEWLINE  Match-any-character operators
	 *                      don't match a newline.
	 */
	bool            compile(const std::string &regex,
	                        int   cflags = REG_EXTENDED);

	/**
	 * Return the last error code generated by compile or
	 * one of the executing methods.
	 *
	 * @return      0 or the last error code
	 */
	int             errorCode();

	/**
	 * Return the error message string for the last error code.
	 *
	 * @return      The error message or empty string
	 *              if no expression was compiled.
	 */
	std::string          errorString() const;


	/**
	 * @return      The regular expression pattern string.
	 */
	std::string          patternString() const;

	/**
	 * @return      The compilation flags used in compile() method.
	 */
	int             compileFlags() const;

	/**
	 * @return true, if the current regex object is compiled.
	 */
	bool            isCompiled() const;


	/**
	 * Execute regular expression matching against the string.
	 * The matching starts at the specified index and return
	 * true on match of false if no match found.
	 *
	 * @note In contrast to the (PCRE) PerlRegEx class, the index
	 * handling is not provided by posix regex.
	 * The PosixRegEx class is using simple str.c_str() + index
	 * construct and adjusts the resulting match offsets.
	 *
	 * The expected number of substrings to match can be specified
	 * in @c count. If the default value of 0 is used, the count as
	 * detected by compile is used instead.
	 * @note If the specified count is greater 0 but smaller than
	 * the effectively number of found matches, the match array
	 * will contain only offsets for captured substring. This is
	 * a different than in PerlRegEx that reports failure.
	 * If the specified count is greater 0 and greater than the
	 * the effectively number of found matches, unused offsets
	 * at the end are filled with to -1.
	 *
	 * If no match was found, the @c sub array will be empty
	 * and false is returned.
	 * If a match is found and the expression was compiled to
	 * capture substrings, the @c sub array will be filled with
	 * the captured substring offset (match_t structures).
	 * The first (index 0) offset pair points to the start of the
	 * first match and the end of the last match.
	 * Unused / optional capturing subpattern offsets will be set
	 * to -1.
	 *
	 * Consult the regexec(3) and regex(7) manual pages
	 * for complete and detailed descriptions.
	 *
	 * @param  sub     array for substring offsets
	 * @param  str     string to match
	 * @param  index   match string starting at index
	 * @param  count   number of expected substring matches
	 * @param  eflags  execution flags described bellow
	 * @return         true on match or false
	 * @throws RegExCompileException if regex is not compiled.
	 * @throws OutOfBoundsException if the index is greater
	 *         than the string length.
	 *
	 * The @c eflags parameter can be set to 0, one or
	 * a bitwise-or of the following options:
	 *
	 * @arg @c REG_NOTBOL   The circumflex character (^) will
	 *                      not match the beginning of string.
	 * @arg @c REG_NOTEOL   The dollar sign ($) will not match
	 *                      the end of string.
	 *
	 * @par Example:
	 * @code
	 * std::string      str("foo = bar trala hoho");
	 * MatchArray  sub;
	 * if( PosixRegEx("=").execute(sub, str) && !sub.empty())
	 * {
	 *   //
	 *   // sub[0].rm_so is 4,
	 *   // sub[0].rm_eo is 5
	 *   //
	 * }
	 * @endcode
	 */
	bool            execute(MatchArray    &sub,
	                        const std::string  &str,
	                        size_t index = 0,
	                        size_t count = 0,
	                        int   eflags = 0);

	/**
	 * Search in string and return an array of captured substrings.
	 *
	 * @param  str     string to search in
	 * @param  index   match string starting at index
	 * @param  count   expected substring count
	 * @param  eflags  execution flags, see execute() method
	 * @return         array of captured substrings
	 * @throws RegExCompileException if regex is not compiled
	 *         or the REG_NOSUB compilation flag was used.
	 * @throws RegExExecuteException on execute failures.
	 * @throws OutOfBoundsException if the index is greater
	 *         than the string length.
	 *
	 * @par Example:
	 * @code
	 * std::string      str("foo = bar trala hoho");
	 * PosixRegEx  reg("^([a-z]+)[ \t]*=[ \t]*(.*)$");
	 * std::vector<std::string> out = reg.capture(str);
	 * //
	 * // out is { "foo = bar trala hoho",
	 * //          "foo",
	 * //          "bar trala hoho"
	 * //        }
	 * @endcode
	 */
	std::vector<std::string>     capture(const std::string &str,
	                        size_t index = 0,
	                        size_t count = 0,
	                        int   eflags = 0);

	/**
	 * Replace (substitute) the first or all matching substrings.
	 *
	 * Substring(s) matching regular expression are replaced with
	 * the string provided in @c rep and a new, modified string
	 * is returned.
	 * If no matches are found, a copy of 'str' string is returned.
	 *
	 * The rep string can contain capturing references "\\1" to "\\9"
	 * that will be substituted with the corresponding captured string.
	 * Prepended "\\" before the reference disables (switches to skip)
	 * the substitution. Note, the notation using double-slash followed
	 * by a digit character, not just "\1" like the "\n" escape sequence.
	 *
	 * @param  str     string that should be matched
	 * @param  rep     replacement substring with optional references
	 * @param  global  if to replace the first or all matches
	 * @param  eflags  execution flags, see execute() method
	 * @return         new string with modification(s)
	 * @throws RegExCompileException if regex is not compiled
	 *         or the REG_NOSUB compilation flag was used.
	 * @throws RegExExecuteException on execute failures.
	 * @throws OutOfBoundsException if the index is greater
	 *         than the string length.
	 *
	 * @par Example:
	 * @code
	 * std::string      str("//foo/.//bar/hoho");
	 * PosixRegEx  reg("([/]+(\\.?[/]+)?)");
	 * std::string      out = reg.replace(str, "/", true);
	 * //
	 * // out is "/foo/bar/hoho"
	 * //
	 * @endcode
	 */
	std::string          replace(const std::string &str,
	                        const std::string &rep,
	                        bool  global = false,
	                        int   eflags = 0);

	/**
	 * Split the specified string into an array of substrings.
	 * The regular expression is used to match the separators.
	 *
	 * If the empty flag is true, empty substring are included
	 * in the resulting array.
	 *
	 * If no separators were found, and the empty flag is true,
	 * the array will contain the input string as its only element.
	 * If the empty flag is false, a empty array is returned.
	 *
	 * @param  str     string that should be splitted
	 * @param  empty   whether to capture empty substrings
	 * @param  eflags  execution flags, see execute() method
	 * @return         array of resulting substrings
	 *                 or empty array on failure
	 * @throws RegExCompileException if regex is not compiled
	 *         or the REG_NOSUB compilation flag was used.
	 * @throws RegExExecuteException on execute failures.
	 * @throws OutOfBoundsException if the index is greater
	 *         than the string length.
	 *
	 * @par Example:
	 * @code
	 * std::string      str("1.23, .50 , , 71.00 , 6.00");
	 * std::vector<std::string> out1 = PosixRegEx("([ \t]*,[ \t]*)").split(str);
	 * //
	 * // out1 is { "1.23", ".50", "71.00", "6.00" }
	 * //
	 * @endcode
	 */
	std::vector<std::string>     split  (const std::string &str,
	                        bool  empty  = false,
	                        int   eflags = 0);

	/**
	 * Match all strings in the array against regular expression.
	 * Returns an array of matching strings.
	 *
	 * @param  src     list of strings to match
	 * @param  eflags  execution flags, see execute() method
	 * @throws RegExCompileException if regex is not compiled
	 *         or the REG_NOSUB compilation flag was used.
	 * @throws RegExExecuteException on execute failures.
	 * @throws OutOfBoundsException if the index is greater
	 *         than the string length.
	 *
	 * @par Example:
	 * @code
	 * std::vector<std::string> src;
	 * src.push_back("\t");
	 * src.push_back("one");
	 * src.push_back("");
	 * src.push_back("two");
	 * src.push_back(" 	");
	 * std::vector<std::string> out = PosixRegEx("[^ \t]").grep(src);
	 * //
	 * // out is { "one", "two" }
	 * //
	 * @endcode
	 */
	std::vector<std::string>     grep   (const std::vector<std::string> &src,
	                        int   eflags = 0);

	/**
	 * Execute regular expression matching against the string.
	 * The matching starts at the specified index and return
	 * true on match of false if no match found.
	 *
	 * See execute() method for description of the @c index
	 * and @c eflags parameters.
	 *
	 * @param  str     string to match
	 * @param  index   match string starting at index
	 * @param  eflags  execution flags, see execute() method
	 * @return         true on match or false
	 * @throws RegExCompileException if regex is not compiled.
	 * @throws RegExExecuteException on execute failures.
	 * @throws OutOfBoundsException if the index is greater
	 *         than the string length.
	 *
	 * @par Example:
	 * @code
	 * std::string      str("foo = bar ");
	 * if( PosixRegEx("^[a-z]+[ \t]*=[ \t]*.*$").match(str))
	 * {
	 * }
	 * @endcode
	 */
	bool            match  (const std::string  &str,
	                        size_t index = 0,
	                        int   eflags = 0) const;

private:
	bool            compiled;
	int             m_flags;
	mutable int     m_ecode;
	mutable std::string  m_error;
	std::string          m_rxstr;
	regex_t         m_regex;
};

} // End of BLOCXX_NAMESPACE

#endif // LIMAL_POSIX_REGEX_HPP
/* vim: set ts=8 sts=8 sw=8 ai noet: */

